#include "aimbot.hpp"
#include "source.hpp"
#include "entity.hpp"
#include "player.hpp"
#include "weapon.hpp"
#include "hooked.hpp"
#include "autowall.hpp"
#include "math.hpp"
#include "displacement.hpp"
#include "lag_compensation.hpp"
#include "anti_aimbot.hpp"
#include "angle_resolver.hpp"
#include "visuals.hpp"
#include "rmenu.hpp"
#include "movement.hpp"

struct TargetListing_t
{
	int index = 0;
	float distance = 0.f;
	float screen_distance = 0.f;
	float hp = 0;

	TargetListing_t(C_BasePlayer* entity)
	{
		index = entity->entindex();
		distance = entity->m_vecOrigin().Distance(cheat::main::local->m_vecOrigin());
		if (auto dummy = Vector::Zero; Drawing::WorldToScreen(entity->m_vecOrigin(),dummy) && !dummy.IsZero()) screen_distance = dummy.Distance(Vector(cheat::game::screen_size.x, cheat::game::screen_size.y, 0));

		hp = entity->m_iHealth();
	}
};

std::vector<TargetListing_t> m_entities;

Vector c_aimbot::get_hitbox(C_BasePlayer* ent, int ihitbox)
{
	if (ihitbox < 0 || ihitbox > 19) return Vector::Zero;

	if (!ent) return Vector::Zero;

	const auto model = ent->GetModel();

	if (!model)
		return Vector::Zero;

	auto pStudioHdr = Source::m_pModelInfo->GetStudioModel(model);

	if (!pStudioHdr)
		return Vector::Zero;

	auto hitbox = pStudioHdr->pHitbox(ihitbox, 0);

	if (!hitbox)
		return Vector::Zero;

	Vector min, max;
	Math::VectorTransform(hitbox->bbmin, ent->m_CachedBoneData().Base()[hitbox->bone], min);
	Math::VectorTransform(hitbox->bbmax, ent->m_CachedBoneData().Base()[hitbox->bone], max);

	auto center = (min + max) / 2.f;

	return center;
}

void c_aimbot::draw_capsule(C_BasePlayer* ent, int ihitbox)
{
	if (ihitbox < 0 || ihitbox > 19) return;

	if (!ent) return;

	const auto model = ent->GetModel();

	if (!model)
		return;

	auto pStudioHdr = Source::m_pModelInfo->GetStudioModel(model);

	if (!pStudioHdr)
		return;

	auto hitbox = pStudioHdr->pHitbox(ihitbox, 0);

	if (!hitbox)
		return;

	//Vector min, max;
	//Math::VectorTransform(hitbox->bbmin, mat[hitbox->bone], min);
	//Math::VectorTransform(hitbox->bbmax, mat[hitbox->bone], max);

	//cheat::features::visuals.draw_capsule(hitbox->bbmin, hitbox->bbmax, hitbox->radius, mat[hitbox->bone], Color::Red(200));
}

Vector c_aimbot::get_hitbox(C_BasePlayer* ent, int ihitbox, matrix3x4_t mat[])
{
	if (ihitbox < 0 || ihitbox > 19) return Vector::Zero;

	if (!ent) return Vector::Zero;

	/*matrix3x4_t mat[128];

	ent->force_bone_rebuild();

	const auto _backup = ent->get_animation_state()->m_bOnGround;
	ent->get_animation_state()->m_bOnGround = 0;
	if (!ent->SetupBones(mat, 128, 0x00000100, ent->m_flSimulationTime())) {
		ent->get_animation_state()->m_bOnGround = _backup;
		return Vector::Zero;
	}
	ent->get_animation_state()->m_bOnGround = _backup;*/

	if (!ent->GetClientRenderable())
		return Vector::Zero;

	const auto model = ent->GetModel();

	if (!model)
		return Vector::Zero;

	auto pStudioHdr = Source::m_pModelInfo->GetStudioModel(model);

	if (!pStudioHdr)
		return Vector::Zero;

	auto hitbox = pStudioHdr->pHitbox(ihitbox, ent->m_nHitboxSet());

	if (!hitbox)
		return Vector::Zero;

	Vector min, max;
	Math::VectorTransform(hitbox->bbmin, mat[hitbox->bone], min);
	Math::VectorTransform(hitbox->bbmax, mat[hitbox->bone], max);

	auto center = (min + max) / 2.f;

	return center;
}

//void  c_aimbot::ClipTraceToPlayers(Vector& absStart, Vector absEnd, unsigned int mask, ITraceFilter* filter, CGameTrace* tr)
//{
//	//TODO: Un-ASM this
//#ifdef _WIN32
//	_asm
//	{
//		mov eax, filter
//		lea ecx, tr
//		push ecx
//		push eax
//		push mask
//		lea edx, absEnd
//		lea ecx, absStart
//		call Engine::Displacement::Data::m_uClipTracePlayers
//		add esp, 0xC
//	}
//#else
//	UTIL_ClipTraceToPlayers(absStart, absEnd, mask, filter, tr, 60.f, 0.f);
//#endif
//}

bool c_aimbot::knifebot_work(CUserCmd* cmd, bool&send_packet)
{
	auto return_value = false;

	m_nBestIndex = -1;

	auto local_weapon = (C_WeaponCSBaseGun*)(Source::m_pEntList->GetClientEntityFromHandle(cheat::main::local->m_hActiveWeapon()));

	if (!local_weapon || !local_weapon->is_knife())
		return return_value;

	if (!knifebot_target() || pBestEntity == nullptr) {
		cheat::features::lagcomp.finish_position_adjustment();
		return return_value;
	}

	Vector tempBestAngle = get_hitbox(pBestEntity, HITBOX_PELVIS);
	auto entAng = Math::CalcAngle(cheat::main::local->GetEyePosition(), tempBestAngle);

	if (!lastAttacked)
	{
		bool stab = false;
		int health = pBestEntity->m_iHealth();
		if (pBestEntity->m_ArmorValue())
		{
			if (health <= 55 &&
				health > 34)
				stab = true;
		}
		else
		{
			if (health <= 65 &&
				health > 40)
				stab = true;
		}

		stab = stab && m_nBestDist <= 32.0f;

		if (cheat::features::aaa.compare_delta(pBestEntity->m_angEyeAngles().y, Math::CalcAngle(cheat::main::local->m_vecOrigin(), pBestEntity->m_vecOrigin()).y, 75)) {
			if (cheat::features::lagcomp.records[pBestEntity->entindex() - 1].backtrack_ticks > 0) {
				if (m_nBestDist < 32.0f)
					stab = true;
				else
				{
					cheat::features::lagcomp.finish_position_adjustment();
					return return_value;
				}
			}
			else
			{
				if (m_nBestDist < 32.0f)
					stab = true;
				else
					stab = false;
			}
		}

		if (m_nBestDist < 32.0f && health >= 90)
			stab = true;

		if (stab)
			cmd->buttons |= IN_ATTACK2;
		else
			cmd->buttons |= IN_ATTACK;

		if (m_nBestDist > 48.0f)
		{
			cheat::features::lagcomp.finish_position_adjustment();
			return return_value;
		}

		float next_shot = (stab ? local_weapon->m_flNextPrimaryAttack() : local_weapon->m_flNextPrimaryAttack()) - Source::m_pGlobalVars->curtime;

		if (!(next_shot > 0))
		{
			cmd->viewangles = entAng;
			cmd->tick_count = cheat::features::lagcomp.records[pBestEntity->entindex()-1].tick_count;
			send_packet = false;
			return_value = true;
		}
	}

	cheat::features::lagcomp.finish_position_adjustment();

	lastAttacked = !lastAttacked;

	return return_value;
}

bool c_aimbot::knifebot_target()
{
	static auto is_visible = [](C_BasePlayer* thisptr, Vector& Start, Vector& End) -> bool
	{
		if (!thisptr) return NULL;

		CGameTrace tr;
		Ray_t ray;
		static CTraceFilter traceFilter;
		traceFilter.pSkip = cheat::main::local;

		ray.Init(Start, End);

		Source::m_pEngineTrace->TraceRay(ray, MASK_SHOT_HULL | CONTENTS_HITBOX, &traceFilter, &tr);
		cheat::features::autowall.FixTraceRay(Start, End, &tr, thisptr);

		return (tr.m_pEnt == thisptr || tr.fraction > 0.99f);
	};

	cheat::features::lagcomp.start_position_adjustment();

	float bestDist = 75;
	for (int i = 0; i < 64; i++)
	{
		auto pBaseEntity = Source::m_pEntList->GetClientEntity(i);
		if (!pBaseEntity)
			continue;
		if (!pBaseEntity->GetClientClass())
			continue;
		if (pBaseEntity->GetClientClass()->m_ClassID != class_ids::CCSPlayer)
			continue;
		if (pBaseEntity == cheat::main::local)
			continue;
		if (pBaseEntity->m_bGunGameImmunity())
			continue;
		if (pBaseEntity->IsDead())
			continue;
		if (pBaseEntity->IsDormant())
			continue;
		if (pBaseEntity->m_iTeamNum() == cheat::main::local->m_iTeamNum())
			continue;

		Vector localPos = cheat::main::local->m_vecOrigin() + Vector(0,0,60);
		Vector basePos = pBaseEntity->m_vecOrigin() + Vector(0, 0, 60);

		if (!is_visible(pBaseEntity, localPos, basePos))
			continue;

		float curDist = localPos.Distance(basePos);
		if (curDist < bestDist)
		{
			bestDist = curDist;
			m_nBestIndex = i;
			pBestEntity = pBaseEntity;
		}
	}

	m_nBestDist = bestDist;
	return m_nBestIndex != -1;
}

bool c_aimbot::hit_chance(C_WeaponCSBaseGun* weapon, float chance)
{
	if (cheat::Cvars.RageBot_HitChance.GetValue() <= 0)
		return true;

	if (chance >= 100.f)
		chance = 100.f;

	if (chance < 1.f)
		chance = 1.f;

	float flSpread = weapon->GetInaccuracy() * 5;
	return ((((100.f - chance) * 0.65f) * 0.01125) >= flSpread);
}

float c_aimbot::can_hit(int hitbox, C_BasePlayer* Entity, Vector position, matrix3x4_t mx[])
{
	static auto is_visible = [](C_BasePlayer* thisptr, Vector& Start, Vector& End) -> bool
	{
		if (!thisptr) return NULL;

		CGameTrace tr;
		Ray_t ray;
		static CTraceFilter traceFilter;
		traceFilter.pSkip = cheat::main::local;

		ray.Init(Start, End);

		Source::m_pEngineTrace->TraceRay(ray, MASK_SHOT_HULL | CONTENTS_HITBOX, &traceFilter, &tr);
		cheat::features::autowall.FixTraceRay(Start, End, &tr, thisptr);

		return (tr.m_pEnt == thisptr || tr.fraction > 0.99f);
	};

	auto local_weapon = (C_WeaponCSBaseGun*)(Source::m_pEntList->GetClientEntityFromHandle(cheat::main::local->m_hActiveWeapon()));

	if (!local_weapon->GetCSWeaponData())
		return 0;

	/*static auto is_visible = [](C_BasePlayer* thisptr, Vector& Start, Vector& End) -> bool
	{
		if (!thisptr) return NULL;

		CGameTrace tr;
		Ray_t ray;
		static CTraceFilter traceFilter;
		traceFilter.pSkip = cheat::main::local;

		ray.Init(Start, End);

		Source::m_pEngineTrace->TraceRay(ray, MASK_SHOT_HULL | CONTENTS_HITBOX, &traceFilter, &tr);
		cheat::features::aimbot.ClipTraceToPlayers(Start, End, MASK_SHOT_HULL | CONTENTS_HITBOX, &traceFilter, &tr);

		return (tr.m_pEnt == thisptr || tr.fraction > 0.99f);
	};*/

	auto cdmg = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), position, cheat::main::local, Entity, hitbox);

	cheat::main::points[Entity->entindex() - 1][hitbox].clear();

	cheat::main::points[Entity->entindex() - 1][hitbox].emplace_back(position);
	
	//return 0;

	//if (local_weapon->GetCSWeaponData() && is_visible(Entity, cheat::main::local->GetEyePosition(), position))
	//	return local_weapon->GetCSWeaponData()->iDamage;

	static std::vector<Vector> points;

	auto nob = (Entity->m_iHealth() < cheat::Cvars.RageBot_MinDamage.GetValue() && cheat::Cvars.RageBot_MinDamage.GetValue() ? Entity->m_iHealth() : cheat::Cvars.RageBot_MinDamage.GetValue());

	if (Entity->get_multipoints(hitbox, points, mx) && !points.empty())
	{
		cheat::main::points[Entity->entindex() - 1][hitbox] = points;

		if (cdmg >= nob)
			return cdmg;

		if (hitbox != 11 && hitbox != 12) {

			if (hitbox == 0 || hitbox == 1) {
				auto dmg = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), points.at(0), cheat::main::local, Entity, hitbox);

				if (dmg >= nob)
					return dmg;
			}

			auto dmg1 = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), points.at(3), cheat::main::local, Entity, hitbox);

			if (dmg1 >= nob)
				return dmg1;

			auto dmg2 = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), points.at(4), cheat::main::local, Entity, hitbox);

			if (dmg2 >= nob)
				return dmg2;
		}
		else
		{
			auto dmg1 = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), points.at(0), cheat::main::local, Entity, hitbox);
			auto dmg2 = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), points.at(1), cheat::main::local, Entity, hitbox);

			if (max(dmg1, dmg2) >= nob)
				return max(dmg1, dmg2);
		}
	}

	if (cdmg >= nob)
		return cdmg;

	return 0;
}

void c_aimbot::DrawHitchanceLines()
{
	auto aechseVektor = [](Vector aechsen, float *forward, float *right, float *up) -> void
	{
		float aechse;
		float sp, sy, cp, cy;

		aechse = aechsen[0] * (3.1415f / 180);
		sp = sin(aechse);
		cp = cos(aechse);

		aechse = aechsen[1] * (3.1415f / 180);
		sy = sin(aechse);
		cy = cos(aechse);

		if (forward)
		{
			forward[0] = cp * cy;
			forward[1] = cp * sy;
			forward[2] = -sp;
		}

		if (right || up)
		{
			float sr, cr;

			aechse = aechsen[2] * (3.1415f / 180);
			sr = sin(aechse);
			cr = cos(aechse);

			if (right)
			{
				right[0] = -1 * sr * sp * cy + -1 * cr * -sy;
				right[1] = -1 * sr * sp * sy + -1 * cr *cy;
				right[2] = -1 * sr * cp;
			}

			if (up)
			{
				up[0] = cr * sp *cy + -sr * -sy;
				up[1] = cr * sp *sy + -sr * cy;
				up[2] = cr * cp;
			}
		}
	};

	auto praviVektor = [](Vector src, Vector &dst) -> void
	{
		float sp, sy, cp, cy;

		Math::SinCos(DEG2RAD(src[1]), &sy, &cy);
		Math::SinCos(DEG2RAD(src[0]), &sp, &cp);

		dst.x = cp * cy;
		dst.y = cp * sy;
		dst.z = -sp;
	};

	auto vekAechse = [this](Vector &forward, Vector &up, Vector &aechse) -> void
	{
		auto CrossProduct = [this](const Vector& a, const Vector& b) -> Vector
		{
			return Vector(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);
		};

		Vector left = CrossProduct(up, forward);
		left.NormalizeInPlace();

		float forwardDist = forward.Length2D();

		if (forwardDist > 0.001f)
		{
			aechse.x = atan2f(-forward.z, forwardDist) * 180 / M_PI_F;
			aechse.y = atan2f(forward.y, forward.x) * 180 / M_PI_F;

			float upZ = (left.y * forward.x) - (left.x * forward.y);
			aechse.z = atan2f(left.z, upZ) * 180 / M_PI_F;
		}
		else
		{
			aechse.x = atan2f(-forward.z, forwardDist) * 180 / M_PI_F;
			aechse.y = atan2f(-left.x, left.y) * 180 / M_PI_F;
			aechse.z = 0;
		}
	};

	auto weap = (C_WeaponCSBaseGun*)(Source::m_pEntList->GetClientEntityFromHandle(cheat::main::local->m_hActiveWeapon()));

	if (!weap)
		return;

	auto weap_data = weap->GetCSWeaponData();

	if (!weap_data)
		return;

	Vector neu = cheat::main::local->GetEyePosition(), traceEnd;;
	QAngle viewAngles = Engine::Movement::Instance()->m_qRealAngles;

	//Math::AngleVectors(viewAngles, &traceEnd);
	//traceEnd = neu + (traceEnd * 8192.0f);

	Vector forward, right, up;
	Math::AngleVectors(viewAngles, &forward, &right, &up);//aechseVektor(aechse, (float*)&forward, (float*)&right, (float*)&up);

	weap->UpdateAccuracyPenalty();
	float weap_sir = weap->GetSpread();
	float weap_inac = weap->GetInaccuracy() + weap->m_fAccuracyPenalty();
	auto recoil_index = weap->m_flRecoilIndex();

	if (weap_sir <= 0.f)
		return;

	for (int i = 0; i < 150; i++)
	{
		float a = RandomFloat(0.f, 1.f);
		float b = RandomFloat(0.f, 6.2831855f);
		float c = RandomFloat(0.f, 1.f);
		float d = RandomFloat(0.f, 6.2831855f);

		float inac = a * weap_inac;
		float sir = c * weap_sir;

		if (weap->m_iItemDefinitionIndex() == 64)
		{
			a = 1.f - a * a;
			a = 1.f - c * c;
		}
		else if (weap->m_iItemDefinitionIndex() == 28 && recoil_index < 3.0f)
		{
			for (int i = 3; i > recoil_index; i--)
			{
				a *= a;
				c *= c;
			}

			a = 1.0f - a;
			c = 1.0f - c;
		}

		Vector sirVec((cos(b) * inac) + (cos(d) * sir), (sin(b) * inac) + (sin(d) * sir), 0), direction;

		direction.x = forward.x + (sirVec.x * right.x) + (sirVec.y * up.x);
		direction.y = forward.y + (sirVec.x * right.y) + (sirVec.y * up.y);
		direction.z = forward.z + (sirVec.x * right.z) + (sirVec.y * up.z);
		direction.Normalize();

		QAngle viewAnglesSpread;
		Math::VectorAngles(direction, up, viewAnglesSpread);
		viewAnglesSpread.Normalize();

		Vector viewForward;
		Math::AngleVectors(viewAnglesSpread, &viewForward);
		viewForward.NormalizeInPlace();

		viewForward = neu + (viewForward *weap_data->flRange);

		trace_t tr;
		Ray_t ray;

		ray.Init(neu, viewForward);

		CTraceFilter filter;
		filter.pSkip = cheat::main::local;

		Source::m_pEngineTrace->TraceRay(ray, MASK_SHOT | CONTENTS_GRATE | CONTENTS_WINDOW, &filter, &tr);

		Source::m_pDebugOverlay->AddBoxOverlay(tr.endpos, Vector(-0.5f,-0.5f,-0.5f), Vector(0.5f, 0.5f, 0.5f), Vector(0,0,0), 255, 0, 0, 0, Source::m_pGlobalVars->interval_per_tick * 2);
	}
}

bool c_aimbot::TraceHitchance(Vector &aechse, C_BasePlayer *ent, float chance)
{
	auto aechseVektor = [](Vector aechsen, float *forward, float *right, float *up) -> void
	{
		float aechse;
		float sp, sy, cp, cy;

		aechse = aechsen[0] * (3.1415f / 180);
		sp = sin(aechse);
		cp = cos(aechse);

		aechse = aechsen[1] * (3.1415f / 180);
		sy = sin(aechse);
		cy = cos(aechse);

		if (forward)
		{
			forward[0] = cp * cy;
			forward[1] = cp * sy;
			forward[2] = -sp;
		}

		if (right || up)
		{
			float sr, cr;

			aechse = aechsen[2] * (3.1415f / 180);
			sr = sin(aechse);
			cr = cos(aechse);

			if (right)
			{
				right[0] = -1 * sr * sp * cy + -1 * cr * -sy;
				right[1] = -1 * sr * sp * sy + -1 * cr *cy;
				right[2] = -1 * sr * cp;
			}

			if (up)
			{
				up[0] = cr * sp *cy + -sr * -sy;
				up[1] = cr * sp *sy + -sr * cy;
				up[2] = cr * cp;
			}
		}
	};

	auto praviVektor = [](Vector src, Vector &dst) -> void
	{
		float sp, sy, cp, cy;

		Math::SinCos(DEG2RAD(src[1]), &sy, &cy);
		Math::SinCos(DEG2RAD(src[0]), &sp, &cp);

		dst.x = cp * cy;
		dst.y = cp * sy;
		dst.z = -sp;
	};

	auto vekAechse = [this](Vector &forward, Vector &up, Vector &aechse) -> void
	{
		auto CrossProduct = [this](const Vector& a, const Vector& b) -> Vector
		{
			return Vector(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);
		};

		Vector left = CrossProduct(up, forward);
		left.NormalizeInPlace();

		float forwardDist = forward.Length2D();

		if (forwardDist > 0.001f)
		{
			aechse.x = atan2f(-forward.z, forwardDist) * 180 / M_PI_F;
			aechse.y = atan2f(forward.y, forward.x) * 180 / M_PI_F;

			float upZ = (left.y * forward.x) - (left.x * forward.y);
			aechse.z = atan2f(left.z, upZ) * 180 / M_PI_F;
		}
		else
		{
			aechse.x = atan2f(-forward.z, forwardDist) * 180 / M_PI_F;
			aechse.y = atan2f(-left.x, left.y) * 180 / M_PI_F;
			aechse.z = 0;
		}
	};

	auto weap = (C_WeaponCSBaseGun*)(Source::m_pEntList->GetClientEntityFromHandle(cheat::main::local->m_hActiveWeapon()));

	if (!weap)
		return false;

	if (chance < 2.f)
		return true;

	auto weap_data = weap->GetCSWeaponData();

	if (!weap_data)
		return false;

	Vector forward, right, up;
	Vector neu = cheat::main::local->GetEyePosition();
	Math::AngleVectors(aechse, &forward, &right, &up);//aechseVektor(aechse, (float*)&forward, (float*)&right, (float*)&up);

	int cHits = 0;
	int cNeededHits = static_cast<int>(150.f * (chance / 100.f));

	weap->UpdateAccuracyPenalty();
	float weap_sir = weap->GetSpread();
	float weap_inac = weap->GetInaccuracy() + weap->m_fAccuracyPenalty();
	auto recoil_index = weap->m_flRecoilIndex();

	if (weap_sir <= 0.f)
		return true;

	for (int i = 0; i < 150; i++)
	{
		float a = RandomFloat(0.f, 1.f);
		float b = RandomFloat(0.f, 6.2831855f);
		float c = RandomFloat(0.f, 1.f);
		float d = RandomFloat(0.f, 6.2831855f);

		float inac = a * weap_inac;
		float sir = c * weap_sir;

		if (weap->m_iItemDefinitionIndex() == 64)
		{
			a = 1.f - a * a;
			a = 1.f - c * c;
		}
		else if (weap->m_iItemDefinitionIndex() == 28 && recoil_index < 3.0f)
		{
			for (int i = 3; i > recoil_index; i--)
			{
				a *= a;
				c *= c;
			}

			a = 1.0f - a;
			c = 1.0f - c;
		}

		Vector sirVec((cos(b) * inac) + (cos(d) * sir), (sin(b) * inac) + (sin(d) * sir), 0), direction;

		direction.x = forward.x + (sirVec.x * right.x) + (sirVec.y * up.x);
		direction.y = forward.y + (sirVec.x * right.y) + (sirVec.y * up.y);
		direction.z = forward.z + (sirVec.x * right.z) + (sirVec.y * up.z);
		direction.Normalize();

		QAngle viewAnglesSpread;
		Math::VectorAngles(direction, up, viewAnglesSpread);
		viewAnglesSpread.Normalize();

		Vector viewForward;
		Math::AngleVectors(viewAnglesSpread, &viewForward);
		viewForward.NormalizeInPlace();

		viewForward = neu + (viewForward *weap_data->flRange);

		trace_t tr;
		Ray_t ray;

		ray.Init(neu, viewForward);

		Source::m_pEngineTrace->ClipRayToEntity(ray, MASK_SHOT | CONTENTS_GRATE | CONTENTS_WINDOW, ent, &tr);

		//Source::m_pDebugOverlay->AddLineOverlay(neu, tr.endpos, 255, 0, 0, false, Source::m_pGlobalVars->interval_per_tick * 2);

		if (tr.m_pEnt == ent)
			++cHits;

		if (static_cast<int>((static_cast<float>(cHits) / 150.f) * 100.f) >= chance)
			return true;

		if ((150 - i + cHits) < cNeededHits)
			return false;
	}
	return false;
}

bool c_aimbot::delay_shot(C_BasePlayer * player, bool & send_packet, c_player_records record, C_WeaponCSBaseGun * local_weapon, bool is_lethal_shot, int hitbox, bool can_hit_other_points)
{
	if (cheat::Cvars.RageBot_DelayShot.GetValue() == 0 || player == nullptr)
		return true;

	auto lul = record.m_Tickrecords;
	auto animstate = player->get_animation_state();
	auto player_weapon = player->get_weapon();

	if (lul.size() <= 2 || animstate == nullptr || player_weapon == nullptr || !local_weapon->IsGun() || local_weapon->m_iItemDefinitionIndex() == weapon_taser)
		return true;

	if (!player_weapon->IsGun() || player_weapon->m_iItemDefinitionIndex() == weapon_taser || (hitbox > 1 && cheat::Cvars.RageBot_DelayShot.GetValue() != 1) || !can_hit_other_points)
		return true;

	auto speed					= animstate->speed_2d;
	auto current_velocity_angle = RAD2DEG(atan2(player->m_vecVelocity().y, player->m_vecVelocity().x));
	auto is_peeking_with_head	= cheat::features::aaa.compare_delta(current_velocity_angle, animstate->abs_yaw, 50) && speed > 70.f;
	auto is_peeklag				= player->get_abs_origin().Distance(lul.front().origin) > 1;
	auto is_speed_around_slowmo = (speed > 20.f && speed < player_weapon->GetMaxWeaponSpeed());
	auto is_being_backtracked	= record.backtrack_ticks > 0 || record.type == RECORD_PRIORITY;
	auto resolver_info			= &cheat::features::aaa.player_resolver_records[player->entindex() - 1];
	auto ipt_doubled			= Source::m_pGlobalVars->interval_per_tick * 2;
	auto v15					= lul.at(1).simulation_time - player->m_flSimulationTime();
	auto unlag					= fabs(player->m_flSimulationTime() - lul.at(1).simulation_time - v15) < ipt_doubled;
	auto delta					= TIME_TO_TICKS(player->m_flSimulationTime() - lul.at(2).simulation_time) < 3 && speed > 90;

	if (cheat::Cvars.RageBot_DelayShot.GetValue() == 1)
	{
		/*if ((is_peeklag || is_speed_around_slowmo) && !is_being_backtracked)
			return (is_lethal_shot || record.type == RECORD_SHOT);
		if (is_peeking_with_head && !is_being_backtracked)
			return (TIME_TO_TICKS(player->m_flSimulationTime() - lul.front().simulation_time) < 2 || speed < 40.f);
		if (speed < 0.1f && cheat::main::shots_fired[player->entindex()-1] > 2)
			return (is_lethal_shot || record.type == RECORD_SHOT);*/
		if (player_weapon->m_iItemDefinitionIndex() == weapon_awp)
			return (unlag || is_being_backtracked || record.type == RECORD_SHOT);
		else if ((Source::m_pGlobalVars->realtime - resolver_info->last_shot_time) < 0.2f/*f && player_weapon->m_flLastShotTime() == local_weapon->m_flLastShotTime()*/)
			return (record.type == RECORD_SHOT || (hitbox != 0));
		else if (cheat::main::shots_fired[player->entindex() - 1] <= 1)
			return (delta || is_lethal_shot || (hitbox == 0 && is_lethal_shot) || is_being_backtracked || record.type == RECORD_SHOT);
		else
		{
			if (speed >= 100.f)
				return (/*TIME_TO_TICKS(player->m_flSimulationTime() - lul.front().simulation_time) >= 1)*/unlag || delta || is_peeking_with_head || record.type == RECORD_SHOT || is_being_backtracked);
			else
				return (delta || is_lethal_shot || (is_lethal_shot && hitbox == 0) || record.type == RECORD_SHOT);
		}
	}
	else
		return (/*TIME_TO_TICKS(player->m_flSimulationTime() - lul.front().simulation_time) >= 1*/unlag || delta || speed < 40.f || is_being_backtracked);

	return false;
}

bool c_aimbot::prefer_baim(C_BasePlayer * player, bool & send_packet, C_WeaponCSBaseGun * local_weapon, bool is_lethal_shot)
{
	if (cheat::Cvars.RageBot_Baim_PreferBaim.GetValue() == 0 || player == nullptr || !local_weapon->GetCSWeaponData() || !player->get_animation_state())
		return false;

	if (cheat::Cvars.RageBot_Baim_PreferBaim.GetValue() == 1)
		return is_lethal_shot;
	else if (cheat::Cvars.RageBot_Baim_PreferBaim.GetValue() == 2)
	{
		if (cheat::main::local->m_vecVelocity().Length2D() > (local_weapon->GetCSWeaponData()->flMaxPlayerSpeed / 3) && local_weapon->m_iItemDefinitionIndex() != weapon_ssg08)
			return true;
		else if (is_lethal_shot)
			return true;
		else if (cheat::features::aaa.sub_59B13C30(player->get_animation_state()) < 20)
			return false;
		else if (local_weapon->GetInaccuracy() >= 0.015f && player->get_abs_origin().Distance(player->m_vecOrigin()) > 2000)
			return true;
		//else if (local_weapon->m_iItemDefinitionIndex() == weapon_ssg08 || local_weapon->m_iItemDefinitionIndex() == weapon_awp)
		//	return true;
	}

	/*auto lul = record.m_Tickrecords;
	auto animstate = player->get_animation_state();
	auto player_weapon = (C_WeaponCSBaseGun*)(Source::m_pEntList->GetClientEntityFromHandle(player->m_hActiveWeapon()));

	if (lul.size() <= 1 || animstate == nullptr || player_weapon == nullptr)
		return true;

	if (!player_weapon->IsGun() || !cheat::features::aaa.player_resolver_records[player->entindex() - 1].fakeangles)
		return true;

	auto speed = animstate->m_flSpeed2D;
	auto current_velocity_angle = RAD2DEG(atan2(player->m_vecVelocity().y, player->m_vecVelocity().x));
	auto is_peeking_with_head = cheat::features::aaa.compare_delta(current_velocity_angle, animstate->m_flGoalFeetYaw, 50);
	auto is_peeklag = player->get_abs_origin().Distance(lul.front().origin) > 1;
	auto is_speed_around_slowmo = (speed > 30.f && speed < player_weapon->GetMaxWeaponSpeed());
	auto is_being_backtracked = record.backtrack_ticks > 0;

	if (cheat::settings.ragebot_delay_shot == 1)
	{
		if ((is_peeklag || is_speed_around_slowmo) && !is_being_backtracked)
			return (is_lethal_shot || record.type == RECORD_SHOT);
		if (is_peeking_with_head && !is_being_backtracked)
			return (TIME_TO_TICKS(player->m_flSimulationTime() - lul.front().simulation_time) < 2 || speed < 40.f);
		if (speed < 0.1f && cheat::main::shots_fired[player->entindex() - 1] > 2)
			return (is_lethal_shot || record.type == RECORD_SHOT);
	}
	else
		return (TIME_TO_TICKS(player->m_flSimulationTime() - lul.front().simulation_time) < 2 || speed < 40.f || is_being_backtracked);*/
	return false;
}

void c_aimbot::visualise_hitboxes(C_BasePlayer* entity, matrix3x4_t *mx, Color color, float time)
{
	auto model = entity->GetModel();

	if (!model)
		return;

	auto studioHdr = Source::m_pModelInfo->GetStudioModel(model);

	if (!studioHdr
		/*|| !entity->SetupBones(matrix, 128, 0x100, 0)*/)
		return;

	auto set = studioHdr->pHitboxSet(entity->m_nHitboxSet());

	if (!set)
		return;

	for (int i = 0; i < set->numhitboxes; i++)
	{
		auto hitbox = set->pHitbox(i);

		if (!hitbox)
			continue;

		Vector min, max, center;
		Math::VectorTransform(hitbox->bbmin, mx[hitbox->bone], min);
		Math::VectorTransform(hitbox->bbmax, mx[hitbox->bone], max);



		if (hitbox->radius != -1) {
			Source::m_pDebugOverlay->AddCapsuleOverlay(min, max, hitbox->radius, color.r(), color.g(), color.b(), 255, time, 0, 1);
		}
		/*else
		{
			Math::VectorTransform((hitbox->bbmin + hitbox->bbmax) * 0.5f, mx[hitbox->bone], center);

			Vector v59 = Vector::Zero;
			Vector v76 = Vector::Zero;

			Math::MatrixAngles(mx[hitbox->bone], &v59, &v76);


			v59.x = 0;

			Source::m_pDebugOverlay->AddBoxOverlay(center, hitbox->bbmin, hitbox->bbmax, v59, color.r(), color.g(), color.b(), 200, time);
		}*/
	}
};

void c_aimbot::autostop(CUserCmd* cmd, bool &send_packet, C_WeaponCSBaseGun* local_weapon/*, C_BasePlayer* best_player, float dmg, bool hitchanced*/)
{
	if ((int)cheat::Cvars.RageBot_AutoStop.GetValue() == 0)
		return;

	//auto should_stop = (!best_player && !hitchanced && dmg == 1337.f) || ((int)cheat::Cvars.RageBot_AutoStop.GetValue() == 3 || (best_player && dmg >= best_player->m_iHealth() && (int)cheat::Cvars.RageBot_AutoStop.GetValue() == 1) || (!hitchanced && (int)cheat::Cvars.RageBot_AutoStop.GetValue() == 2));

	if (cheat::main::fast_autostop && local_weapon && local_weapon->GetCSWeaponData())
	{
		switch ((int)cheat::Cvars.RageBot_AutoStopMethod.GetValue())
		{
		case 0:
		{
			auto velocity = cheat::main::local->m_vecVelocity();

			float maxspeed = 30.f;

			if (cheat::main::local->m_bIsScoped())
				maxspeed = local_weapon->GetCSWeaponData()->flMaxPlayerSpeedAlt;
			else
				maxspeed = local_weapon->GetCSWeaponData()->flMaxPlayerSpeed;

			if (cheat::main::local->m_vecVelocity().Length2D() > (maxspeed * 0.24f))
			{
				//	cmd->buttons |= IN_WALK;
				Engine::Movement::Instance()->quick_stop(cmd);
			}
		}
		break;
		case 1:
		{
			auto velocity = cheat::main::local->m_vecVelocity();

			float maxspeed = 30.f;

			if (cheat::main::local->m_bIsScoped())
				maxspeed = local_weapon->GetCSWeaponData()->flMaxPlayerSpeedAlt;
			else
				maxspeed = local_weapon->GetCSWeaponData()->flMaxPlayerSpeed;

			if (cheat::main::local->m_vecVelocity().Length2D() > (maxspeed * 0.24f))
			{
				//	cmd->buttons |= IN_WALK;
				Engine::Movement::Instance()->quick_stop(cmd);
			}

			if (!(cheat::game::pressed_keys[(int)cheat::Cvars.Exploits_fakeduck.GetValue()] && (int)cheat::Cvars.Exploits_fakeduck.GetValue() != 0))
				cmd->buttons |= IN_DUCK;
		}
		break;
		case 2:
		{
			Engine::Movement::Instance()->quick_stop(cmd);
		}
		break;
		}
	}

	cheat::main::fast_autostop = false;
}

float c_aimbot::check_wall(C_WeaponCSBaseGun* local_weapon, Vector point, C_BasePlayer* entity)
{
	auto weapon_info = local_weapon->GetCSWeaponData();

	if (!weapon_info)
		return -1.f;

	float autowall_dmg = 0;

	Vector direction;
	Math::AngleVectors(point, &direction);

	Vector start = cheat::main::local->GetEyePosition();

	float maxRange = weapon_info->flRange;
	float pointDist = start.Distance(point);

	if (pointDist > maxRange)
		return -1.0f;

	autowall_dmg = weapon_info->iDamage;

	auto max_range = weapon_info->flRange * 2;

	Vector end = start + (direction * max_range);
	auto currentDistance = 0.f;

	CGameTrace enterTrace;

	CTraceFilter filter;
	filter.pSkip = cheat::main::local;

	cheat::features::autowall.TraceLine(start, end, MASK_SHOT | CONTENTS_GRATE, cheat::main::local, &enterTrace);

	if (enterTrace.fraction == 1.0f)
		autowall_dmg = 0.f;
	else
		//calculate the damage based on the distance the bullet traveled.
		currentDistance += enterTrace.fraction * max_range;

	//Let's make our damage drops off the further away the bullet is.
	autowall_dmg *= pow(weapon_info->flRangeModifier, (currentDistance / 500.f));

	surfacedata_t *enterSurfaceData = Source::m_pPhysProps->GetSurfaceData(enterTrace.surface.surfaceProps);
	float enterSurfPenetrationModifier = enterSurfaceData->game.penetrationmodifier;

	if (currentDistance > 3000.0 && weapon_info->flPenetration > 0.f || enterSurfPenetrationModifier < 0.1f)
		return -1.f;

	//if (enterTrace.m_pEnt != nullptr)
	//{
	//	//This looks gay as fuck if we put it into 1 long line of code.
	//	bool canDoDamage = (enterTrace.hitgroup != HITGROUP_GEAR && enterTrace.hitgroup != HITGROUP_GENERIC);
	//	bool isPlayer = (enterTrace.m_pEnt->GetClientClass() && enterTrace.m_pEnt->GetClientClass()->m_ClassID == class_ids::CCSPlayer);
	//	bool isEnemy = (cheat::main::local->m_iTeamNum() != ((C_BasePlayer*)enterTrace.m_pEnt)->m_iTeamNum());
	//	bool onTeam = (((C_BasePlayer*)enterTrace.m_pEnt)->m_iTeamNum() == 2 || ((C_BasePlayer*)enterTrace.m_pEnt)->m_iTeamNum() == 3);

	//	//TODO: Team check config
	//	if ((canDoDamage && isPlayer && isEnemy) && onTeam)
	if (entity)
	{
		int armorValue = entity->m_ArmorValue();
		int hitGroup = enterTrace.hitgroup;

		//Fuck making a new function, lambda beste. ~ Does the person have armor on for the hitbox checked?
		auto IsArmored = [&enterTrace, entity]()->bool
		{
			if ((DWORD)entity < 50977)
				return false;

			switch (enterTrace.hitgroup)
			{
			case HITGROUP_HEAD:
				return entity->m_bHasHelmet(); //Fuck compiler errors - force-convert it to a bool via (!!)
			case HITGROUP_GENERIC:
			case HITGROUP_CHEST:
			case HITGROUP_STOMACH:
			case HITGROUP_LEFTARM:
			case HITGROUP_RIGHTARM:
				return true;
			default:
				return false;
			}
		};

		switch (hitGroup)
		{
		case HITGROUP_HEAD:
			autowall_dmg *= /*hasHeavyArmor ? 2.f :*/ 4.f; //Heavy Armor does 1/2 damage
			break;
		case HITGROUP_STOMACH:
			autowall_dmg *= 1.25f;
			break;
		case HITGROUP_LEFTLEG:
		case HITGROUP_RIGHTLEG:
			autowall_dmg *= 0.75f;
			break;
		default:
			break;
		}

		if (armorValue > 0 && IsArmored())
		{
			float bonusValue = 1.f, armorBonusRatio = 0.5f, armorRatio = weapon_info->flArmorRatio / 2.f;

			////Damage gets modified for heavy armor users
			//if (hasHeavyArmor)
			//{
			//	armorBonusRatio = 0.33f;
			//	armorRatio *= 0.5f;
			//	bonusValue = 0.33f;
			//}

			auto NewDamage = autowall_dmg * armorRatio;

			//if (hasHeavyArmor)
			//	NewDamage *= 0.85f;

			if (((autowall_dmg - (autowall_dmg * armorRatio)) * (bonusValue * armorBonusRatio)) > armorValue)
				NewDamage = autowall_dmg - (armorValue / armorBonusRatio);

			autowall_dmg = NewDamage;
		}
	}

	//	if (!canDoDamage && isPlayer && isEnemy)
	//		return -1.f;

	//	return autowall_dmg;
	//}

	auto penetrate_count = 4;

	if (!cheat::features::autowall.HandleBulletPenetration(weapon_info, enterTrace, start, direction, penetrate_count, autowall_dmg, weapon_info->flPenetration, cheat::convars::ff_damage_bullet_penetration, true))
		return -1.f;

	if (penetrate_count <= 0)
		return -1.f;

	return autowall_dmg;
}

bool c_aimbot::work(CUserCmd* cmd, bool &send_packet)
{
	m_entities.clear();
	C_BasePlayer* best_player = nullptr;
	Vector best_hitbox = Vector::Zero;
	int	best_hitboxid = -1;
	static float last_shoot_tick = 0;

	auto local_weapon = (C_WeaponCSBaseGun*)(Source::m_pEntList->GetClientEntityFromHandle(cheat::main::local->m_hActiveWeapon()));

	if (!cheat::main::local || !local_weapon) return false;

	auto IsGrenade = [](int item)
	{
		if (item == weapon_flashbang
			|| item == weapon_hegrenade
			|| item == weapon_smokegrenade
			|| item == weapon_molotov
			|| item == weapon_decoy
			|| item == weapon_incgrenade
			|| item == weapon_tagrenade)
			return true;
		else
			return false;
	};

	if (!cheat::Cvars.RageBot_Enable.GetValue() || IsGrenade(local_weapon->m_iItemDefinitionIndex()) || local_weapon->m_iItemDefinitionIndex() == weapon_knife_ct || local_weapon->m_iItemDefinitionIndex() == weapon_knife_t)
		return false;

	if (cheat::Cvars.RageBot_autor8.GetValue())
	{
		if (local_weapon->m_iItemDefinitionIndex() == 64)
		{
			auto v7 = Source::m_pGlobalVars->curtime;
			if (r8cock_time <= (Source::m_pGlobalVars->frametime + v7))
				r8cock_time = v7 + 0.249f;
			else
				cmd->buttons |= IN_ATTACK;
		}
		else
		{
			r8cock_time = 0.0;
		}

		local_weapon->m_flPostponeFireReadyTime() = r8cock_time;
	}

	if (m_entities.empty()) {
		for (auto idx = 0; idx < 64; idx++)
		{
			auto entity = (C_BasePlayer*)Source::m_pEntList->GetClientEntity(idx);

			if (!entity ||
				!entity->IsPlayer() ||
				entity->IsDormant() ||
				entity->m_iHealth() <= 0 ||
				entity->m_iTeamNum() == cheat::main::local->m_iTeamNum() ||
				entity->m_bGunGameImmunity()
				) continue;

			m_entities.push_back(TargetListing_t(entity));

			auto resolve_info = &cheat::features::aaa.player_resolver_records[entity->entindex() - 1];

			resolve_info->freestanding_record.reset();

			const float height = Source::m_pGameMovement->GetPlayerViewOffset((entity->m_flDuckAmount() > 0.8f)).z;

			Vector direction_1, direction_2;
			Math::AngleVectors(Vector(0.f, Math::CalcAngle(cheat::main::local->m_vecOrigin(), entity->m_vecOrigin()).y - 90.f, 0.f), &direction_1);
			Math::AngleVectors(Vector(0.f, Math::CalcAngle(cheat::main::local->m_vecOrigin(), entity->m_vecOrigin()).y + 90.f, 0.f), &direction_2);

			auto left_eye_pos = entity->m_vecOrigin() + Vector(0, 0, height) + (direction_1 * 16.f);
			auto right_eye_pos = entity->m_vecOrigin() + Vector(0, 0, height) + (direction_2 * 16.f);

			resolve_info->freestanding_record.left_damage = check_wall(local_weapon, left_eye_pos, entity);   //cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), left_eye_pos, cheat::main::local, entity,0);
			resolve_info->freestanding_record.right_damage = check_wall(local_weapon, right_eye_pos, entity); //cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), right_eye_pos, cheat::main::local, entity,0);

			Ray_t ray;
			trace_t trace;
			CTraceFilterWorldOnly filter;

			filter.pSkip = cheat::main::local;

			ray.Init(cheat::main::local->GetEyePosition(), left_eye_pos);
			Source::m_pEngineTrace->TraceRay(ray, MASK_ALL, &filter, &trace);
			resolve_info->freestanding_record.left_fraction = trace.fraction;

			ray.Init(cheat::main::local->GetEyePosition(), right_eye_pos);
			Source::m_pEngineTrace->TraceRay(ray, MASK_ALL, &filter, &trace);
			resolve_info->freestanding_record.right_fraction = trace.fraction;
		}

		std::sort(m_entities.begin(), m_entities.end(), [&](const TargetListing_t& a, const TargetListing_t& b)
		{
			if (cheat::Cvars.RageBot_TargetSelection.GetValue() == 0)
				return (a.hp < b.hp);
			else if (cheat::Cvars.RageBot_TargetSelection.GetValue() == 1)
				return (a.distance < b.distance);
			else
				return (a.screen_distance < b.screen_distance);

			return false;
		}
		);
	}

	if (m_entities.empty())
		return false;

	auto is_zeus = local_weapon->m_iItemDefinitionIndex() == weapon_taser;

	cheat::features::lagcomp.start_position_adjustment();

	float max_damage = cheat::Cvars.RageBot_MinDamage.GetValue();

	static int hitboxesLoop[] =
	{
		HITBOX_HEAD, //0
		HITBOX_NECK,
		HITBOX_PELVIS,
		HITBOX_BODY,		// 2
		HITBOX_CHEST,			//
		HITBOX_LEFT_FOREARM,	// 4
		HITBOX_RIGHT_FOREARM,	//
		HITBOX_LEFT_HAND,		// 6
		HITBOX_RIGHT_HAND,		//
		HITBOX_LEFT_THIGH,		// 8
		HITBOX_RIGHT_THIGH,		//
		HITBOX_LEFT_CALF,		// 10
		HITBOX_RIGHT_CALF,		//
		HITBOX_LEFT_FOOT,		// 12
		HITBOX_RIGHT_FOOT		// 13
	};

	auto should_hitscan = cheat::Cvars.RageBot_Hitboxes.GetValue() > 0;

	int checked_targets = 0;
	int valid_targets_checked = 0;

	for (auto& noob : m_entities)
	{
		if (noob.index == 0)
			continue;

		if (checked_targets > 2)
			break;

		auto entity = (C_BasePlayer*)Source::m_pEntList->GetClientEntity(noob.index);

		if (!entity ||
			!entity->IsPlayer() ||
			entity->IsDormant() ||
			entity->m_iHealth() <= 0 ||
			entity->m_iTeamNum() == cheat::main::local->m_iTeamNum() ||
			entity->IsDead() ||
			entity->m_bGunGameImmunity()
			) continue;

		auto animstate = entity->get_animation_state();

		if (!animstate)
			continue;

		int loopsize = 11;//ARRAYSIZE(hitboxesLoop);

		auto resolve_info = &cheat::features::aaa.player_resolver_records[noob.index - 1];

		auto mx = cheat::features::lagcomp.records[noob.index - 1].matrix;

		auto backtrack_matrix_is_valid = cheat::features::lagcomp.records[noob.index - 1].matrix_valid;

		float maxRange = local_weapon->GetCSWeaponData()->flRange;

		auto distance = noob.distance;

		if (distance > maxRange)
			continue;

		float chest_damage = 0.f;
		float head_damage = 0.f;
		float neck_damage = 0.f;

		if (should_hitscan)
		{
			auto hitbox_chest = get_hitbox(entity, HITBOX_PELVIS, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));
			chest_damage = can_hit(HITBOX_PELVIS, entity, hitbox_chest, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));

			if (valid_targets_checked < 4) {
				auto hitbox_head = get_hitbox(entity, 0, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));
				head_damage = can_hit(0, entity, hitbox_head, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));
			}

			auto hitbox_neck = get_hitbox(entity, 1, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));
			neck_damage = can_hit(1, entity, hitbox_neck, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));
		}
		else
			loopsize = 1;

		if (is_zeus)
			loopsize = 5;

		auto should_only_baim = (!cheat::Cvars.RageBot_Hitboxes.Has(0) || (resolve_info->fakeangles && cheat::features::aaa.sub_59B13C30(entity->get_animation_state()) > 25 && cheat::Cvars.RageBot_Baim_fake.GetValue()) || is_zeus || (cheat::Cvars.RageBot_Baim_air.GetValue() && !(entity->m_fFlags() & FL_ONGROUND || animstate->on_ground)));
		auto should_baim = (prefer_baim(entity, send_packet, local_weapon, (chest_damage > entity->m_iHealth())));
		auto should_baim_lethal = (cheat::Cvars.RageBot_Baim_accurate.GetValue() && (chest_damage > entity->m_iHealth()) || (cheat::main::shots_total[noob.index - 1] > (int)cheat::Cvars.RageBot_Baim_AfterXshots.GetValue() && (int)cheat::Cvars.RageBot_Baim_AfterXshots.GetValue() > 0));
		
		auto priority = (((should_only_baim || should_baim || should_baim_lethal) && chest_damage > 0.f && (cheat::features::lagcomp.records[noob.index - 1].type <= RECORD_NORMAL && !should_baim_lethal && !should_only_baim)) ? HITBOX_PELVIS : (head_damage > neck_damage && cheat::main::shots_total[noob.index - 1] < 1 ? HITBOX_HEAD : HITBOX_NECK));
		
		if (cheat::Cvars.Ragebot_headaim_only_on_shot.GetValue())
			priority = (cheat::features::lagcomp.records[noob.index - 1].type == RECORD_SHOT && (head_damage > neck_damage && neck_damage > 0 && head_damage > 0 && cheat::main::shots_total[noob.index - 1] < 1) ? HITBOX_HEAD : HITBOX_PELVIS);

		auto phitbox = get_hitbox(entity, priority, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));
		auto pdmg = can_hit(priority, entity, phitbox, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));

		valid_targets_checked++;

		if (!phitbox.IsZero() && (pdmg > max_damage || (pdmg > noob.hp && cheat::Cvars.RageBot_ScaledmgOnHp.GetValue())))
		{
			max_damage = pdmg;
			best_player = entity;
			best_hitbox = phitbox;
			best_hitboxid = priority;
			break;
		}
		else
		{
			for (auto i = (loopsize/* - min(valid_targets_checked, loopsize - 1)*/); i >= 0; i--)
			{
				if (cheat::Cvars.Ragebot_headaim_only_on_shot.GetValue() && cheat::features::lagcomp.records[noob.index - 1].type != RECORD_SHOT && (i <= 1 || i == HITBOX_UPPER_CHEST || i == HITBOX_THORAX))
					continue;

				if (!should_hitscan && i <= 1)
					continue;

				if (should_hitscan && ((!cheat::Cvars.RageBot_Hitboxes.Has(0) && (i == HITBOX_HEAD || i == HITBOX_NECK)) ||
					(!cheat::Cvars.RageBot_Hitboxes.Has(1) && i >= HITBOX_PELVIS && i <= HITBOX_UPPER_CHEST) ||
					(!cheat::Cvars.RageBot_Hitboxes.Has(2) && i >= HITBOX_RIGHT_HAND && i <= HITBOX_LEFT_FOREARM) ||
					(!cheat::Cvars.RageBot_Hitboxes.Has(3) && i >= HITBOX_RIGHT_THIGH && i <= HITBOX_LEFT_CALF) ||
					(!cheat::Cvars.RageBot_Hitboxes.Has(4) && i >= HITBOX_RIGHT_FOOT && i <= HITBOX_LEFT_FOOT)))
					continue;

				if (i > loopsize)
					break;

				if (is_zeus && ((i != HITBOX_PELVIS || i != HITBOX_BODY) || chest_damage < 0 && i > 1))
					continue;

				if (((i <= 1 || i == HITBOX_UPPER_CHEST || i == HITBOX_THORAX)) && (should_only_baim || should_baim || should_baim_lethal) && chest_damage > 0.f)
					continue;

				auto hitbox = get_hitbox(entity, hitboxesLoop[i], (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));

				if (hitbox.IsZero())
					continue;

				auto dmg = can_hit(hitboxesLoop[i], entity, hitbox, (backtrack_matrix_is_valid ? mx : entity->m_CachedBoneData().Base()));

				if (dmg > max_damage || (dmg > noob.hp && cheat::Cvars.RageBot_ScaledmgOnHp.GetValue()))
				{
					max_damage = dmg;
					best_player = entity;
					best_hitbox = hitbox;
					best_hitboxid = hitboxesLoop[i];
				}
			}

			if (max_damage != cheat::Cvars.RageBot_MinDamage.GetValue())
				break;

			checked_targets++;
		}
	}

	float max_dmg = cheat::Cvars.RageBot_MinDamage.GetValue();

	if (best_player && best_hitboxid >= 0 && best_player->get_multipoints(best_hitboxid, cheat::main::points[best_player->entindex() - 1][best_hitboxid], (cheat::features::lagcomp.records[best_player->entindex() - 1].matrix_valid ? cheat::features::lagcomp.records[best_player->entindex() - 1].matrix : best_player->m_CachedBoneData().Base())))
	{
		auto points = cheat::main::points[best_player->entindex() - 1][best_hitboxid];

		if (cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), points.back()) > max_dmg && best_hitboxid != 11 && best_hitboxid != 12)
			best_hitbox = points.back();
		else {
			for (auto point : points)
			{
				auto dmg = cheat::features::autowall.CanHit(cheat::main::local->GetEyePosition(), point);

				if (dmg > max_dmg)
				{
					max_dmg = dmg;
					best_hitbox = point;
				}
			}
		}
	}

	auto hitchance = false;
	auto aim_angles = QAngle(0, 0, 0);

	if (best_player != nullptr && !best_hitbox.IsZero()) 
	{
		Vector aye_position = cheat::main::local->GetEyePosition();

		aim_angles = Math::CalcAngle(aye_position, best_hitbox);
		aim_angles.Clamp();

		hitchance = TraceHitchance(Vector(aim_angles.x, aim_angles.y, aim_angles.z), best_player, cheat::Cvars.RageBot_HitChance.GetValue() /*(cheat::game::pressed_keys[88] ? cheat::settings.ragebot_hitchance_fakeduck : cheat::settings.ragebot_hitchance)*/);
	}

	cheat::features::lagcomp.finish_position_adjustment();

	if (!best_player || best_hitbox.IsZero() || aim_angles.IsZero())
		return false;

	auto tick_record = -1;

	auto entity_index = best_player->entindex() - 1;

	auto mx = cheat::features::lagcomp.records[entity_index].matrix;

	auto is_zoomable_weapon = (local_weapon->m_iItemDefinitionIndex() == weapon_ssg08 || local_weapon->m_iItemDefinitionIndex() == weapon_awp || local_weapon->m_iItemDefinitionIndex() == weapon_scar20 || local_weapon->m_iItemDefinitionIndex() == weapon_g3sg1);
	auto sniper = (local_weapon->m_iItemDefinitionIndex() == weapon_ssg08 || local_weapon->m_iItemDefinitionIndex() == weapon_awp);
	auto fakeduck = (cheat::game::pressed_keys[(int)cheat::Cvars.Exploits_fakeduck.GetValue()] && (int)cheat::Cvars.Exploits_fakeduck.GetValue() != 0);


	if (local_weapon->IsGun() && local_weapon->IsFireTime() && (cheat::Cvars.RageBot_AutoFire.GetValue() || (cheat::game::pressed_keys[(int)cheat::Cvars.RageBot_Key.GetValue()] && (int)cheat::Cvars.RageBot_Key.GetValue() != 0))/*&& cheat::game::pressed_keys[6]*/ && (delay_shot(best_player, send_packet, cheat::features::lagcomp.records[entity_index], local_weapon, max_dmg >= best_player->m_iHealth(), best_hitboxid, best_player->m_vecOrigin().Distance(cheat::main::local->m_vecOrigin()) > 2000) || fakeduck || is_zeus)/* && cheat::features::lagcomp.records[entity_index].type == RECORD_SHOT*/)
	{
		cheat::main::fast_autostop = ((int)cheat::Cvars.RageBot_AutoStop.GetValue() == 3 || (best_player && max_dmg >= best_player->m_iHealth() && (int)cheat::Cvars.RageBot_AutoStop.GetValue() == 1) || (!hitchance && (int)cheat::Cvars.RageBot_AutoStop.GetValue() == 2));

		//autostop(cmd, send_packet, local_weapon, best_player, max_dmg, hitchance);
		tick_record = cheat::features::lagcomp.records[entity_index].tick_count;

		auto can_shoot_if_fakeduck = (Source::m_pGlobalVars->tickcount - last_shoot_tick) > 20/* && fabs(Source::m_pClientState->m_iChockedCommands - (int)cheat::Cvars.Misc_fakelag_value.GetValue()) > 9*/;

		if (cheat::Cvars.RageBot_AutoScope.GetValue() && local_weapon->m_zoomLevel() == 0 && is_zoomable_weapon)
			cmd->buttons |= 0x800u;
		else/* if ((local_weapon->m_fAccuracyPenalty() <= 0.004f && sniper && cheat::Cvars.RageBot_HitChance.GetValue() > 0.f) || !sniper || cheat::Cvars.RageBot_HitChance.GetValue() <= 0.f)*/
		{
			if (hitchance && ((fakeduck && can_shoot_if_fakeduck) || !fakeduck) && !(cmd->buttons & IN_ZOOM))
			{
				cmd->viewangles = aim_angles;
				cmd->buttons |= IN_ATTACK;

				if (tick_record != -1 && cheat::features::lagcomp.records[entity_index].matrix_valid)
					cmd->tick_count = tick_record;
				else if (!cheat::features::lagcomp.is_time_delta_too_large(best_player->m_flSimulationTime() + cheat::main::lerp_time))
					cmd->tick_count = TIME_TO_TICKS(best_player->m_flSimulationTime() + cheat::main::lerp_time);

				cheat::main::shots_fired[entity_index] += 1;
				cheat::main::shots_total[entity_index] += 1;
				cheat::features::aaa.player_resolver_records[entity_index].missed_shots[cheat::features::aaa.player_resolver_records[entity_index].resolving_method]++;

				if (!fakeduck && !send_packet && cheat::Cvars.RageBot_SilentAim.GetValue() == 2) {
					send_packet = true;
					cheat::features::antiaimbot.skip_lags_this_tick = true;
				}

				auto matrix = (cheat::features::lagcomp.records[entity_index].matrix_valid ? mx : best_player->m_CachedBoneData().Base());

				//visualise_hitboxes(best_player, matrix, Color::Red(), 6);

				if (auto net = Source::m_pEngine->GetNetChannelInfo(); net != nullptr && (cheat::features::lagcomp.records[entity_index].m_Tickrecords.size() > cheat::features::lagcomp.records[entity_index].backtrack_ticks && cheat::features::lagcomp.records[entity_index].m_Tickrecords.size() > 1)) {
					auto impact_time = Source::m_pGlobalVars->curtime /*- net->GetLatency(FLOW_INCOMING) - net->GetLatency(FLOW_OUTGOING)*/ + /*Source::m_pGlobalVars->interval_per_tick*/net->GetLatency(MAX_FLOWS);
					cheat::main::fired_shot.push_back(_shotinfo(best_player, matrix, cheat::main::local->GetEyePosition(), best_hitbox, &cheat::features::lagcomp.records[entity_index], cheat::features::lagcomp.records[entity_index].m_Tickrecords.at(cheat::features::lagcomp.records[entity_index].backtrack_ticks), impact_time));
				}

				if (!cheat::Cvars.RageBot_SilentAim.GetValue())
					Source::m_pEngine->SetViewAngles(aim_angles);

				last_shoot_tick = Source::m_pGlobalVars->tickcount;

				return true;
			}
		}
		/*else if (cheat::game::pressed_keys[16])
			Engine::Movement::Instance()->quick_stop(cmd);*/
	}
	else
		if (local_weapon->IsGun() && (cheat::Cvars.RageBot_AutoFire.GetValue() || (cheat::game::pressed_keys[(int)cheat::Cvars.RageBot_Key.GetValue()] && (int)cheat::Cvars.RageBot_Key.GetValue() != 0)))
			cheat::main::fast_autostop = ((int)cheat::Cvars.RageBot_AutoStop.GetValue() == 3);

	return false;
}